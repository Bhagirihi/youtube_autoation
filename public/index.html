<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Horror Podcast — YouTube Pipeline</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,opsz,wght@0,9..40,400;0,9..40,500;0,9..40,600;0,9..40,700&family=DM+Serif+Display&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #0f0f0f;
      --surface: #1a1a1a;
      --surface-hover: #252525;
      --border: #2d2d2d;
      --text: #f1f1f1;
      --text-muted: #909090;
      --accent: #ff0000;
      --accent-hover: #cc0000;
      --accent-dim: rgba(255, 0, 0, 0.15);
      --success: #00c853;
      --danger: #ff5252;
      --radius: 8px;
      --radius-sm: 6px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      color: var(--text);
      font-family: "DM Sans", -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 15px;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }
    .container { max-width: 1100px; margin: 0 auto; padding: 2rem 1.5rem; }
    .page-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 2rem;
      padding-bottom: 1.5rem;
      border-bottom: 1px solid var(--border);
    }
    .page-header h1 {
      font-family: "DM Serif Display", Georgia, serif;
      font-size: 1.5rem;
      font-weight: 400;
      margin: 0;
      color: var(--text);
      letter-spacing: -0.02em;
    }
    .page-header .tagline {
      color: var(--text-muted);
      font-size: 0.9rem;
      margin: 0.25rem 0 0 0;
    }
    .header-actions { display: flex; align-items: center; gap: 0.75rem; }

    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 1.5rem;
      margin-bottom: 1.5rem;
    }
    .card-title {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin: 0 0 1rem 0;
    }

    /* Pipeline steps */
    .pipeline-intro {
      color: var(--text-muted);
      font-size: 0.9rem;
      margin-bottom: 1.25rem;
    }
    .pipeline-intro strong { color: var(--text); }
    .run-full-wrap {
      margin-bottom: 1.5rem;
    }
    .btn {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.6rem 1.25rem;
      font-family: inherit;
      font-size: 0.9rem;
      font-weight: 500;
      color: #fff;
      background: var(--accent);
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: background 0.2s;
    }
    .btn:hover { background: var(--accent-hover); }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .btn:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
    .btn-outline {
      background: transparent;
      color: var(--text-muted);
      border: 1px solid var(--border);
    }
    .btn-outline:hover { color: var(--text); border-color: var(--text-muted); }
    .btn-sm { padding: 0.35rem 0.75rem; font-size: 0.8125rem; }
    .steps-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 0.75rem;
    }
    .step-card {
      background: var(--surface-hover);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .step-card.done { border-color: rgba(0, 200, 83, 0.4); background: rgba(0, 200, 83, 0.06); }
    .step-card.running { border-color: var(--accent-dim); background: var(--accent-dim); }
    .step-name { font-weight: 500; font-size: 0.9rem; color: var(--text); }
    .step-meta { font-size: 0.75rem; color: var(--text-muted); display: flex; align-items: center; gap: 0.35rem; }
    .step-status-dot {
      width: 6px; height: 6px; border-radius: 50%;
      background: var(--text-muted);
    }
    .step-card.done .step-status-dot { background: var(--success); }
    .step-card.running .step-status-dot { background: var(--accent); animation: pulse 1s ease infinite; }
    @keyframes pulse { 50% { opacity: 0.5; } }
    .step-card .btn { width: 100%; justify-content: center; margin-top: 0.25rem; }

    /* Log */
    #log {
      font-family: "SF Mono", "Consolas", "Monaco", monospace;
      font-size: 0.8rem;
      line-height: 1.5;
      background: #0a0a0a;
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 1rem 1.25rem;
      min-height: 140px;
      max-height: 260px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-word;
      color: var(--text-muted);
    }
    #log:empty::before { content: "Log output appears here when you run the pipeline or a step."; color: var(--text-muted); }

    /* Output */
    .output-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
    }
    @media (max-width: 640px) { .output-grid { grid-template-columns: 1fr; } }
    .output-item label {
      display: block;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.5rem;
    }
    .output-item img, .output-item video {
      width: 100%;
      border-radius: var(--radius-sm);
      border: 1px solid var(--border);
      background: var(--surface-hover);
      display: block;
    }
    .output-item video { max-height: 240px; }
    .output-placeholder { font-size: 0.85rem; color: var(--text-muted); }

    /* Story / YouTube details */
    #unsplashHint {
      font-size: 0.85rem;
      color: var(--text-muted);
      background: var(--surface-hover);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 0.5rem 0.75rem;
      margin-bottom: 1rem;
      display: none;
    }
    #unsplashHint strong { color: var(--text); }
    .studio-section { margin-bottom: 1.25rem; }
    .studio-section:last-child { margin-bottom: 0; }
    .studio-section-title {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.5rem;
    }
    .title-section {
      display: grid;
      grid-template-columns: 180px 1fr;
      gap: 1rem;
      align-items: start;
      margin-bottom: 1rem;
    }
    @media (max-width: 600px) { .title-section { grid-template-columns: 1fr; } }
    .title-section-img-wrap {
      aspect-ratio: 16/10;
      border-radius: var(--radius-sm);
      overflow: hidden;
      background: var(--surface-hover);
    }
    .title-section-img-wrap img { width: 100%; height: 100%; object-fit: cover; display: block; }
    .title-section-img-wrap .placeholder {
      width: 100%; height: 100%;
      display: flex; align-items: center; justify-content: center;
      color: var(--text-muted); font-size: 0.8rem;
    }
    .title-section-text { font-size: 1rem; font-weight: 500; color: var(--text); line-height: 1.4; }
    .story-cards { display: flex; flex-direction: column; gap: 1rem; }
    .story-card {
      background: var(--surface-hover);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      overflow: hidden;
      display: grid;
      grid-template-columns: 200px 1fr;
      gap: 0;
    }
    @media (max-width: 640px) { .story-card { grid-template-columns: 1fr; } }
    .story-card .img-wrap {
      aspect-ratio: 4/3;
      background: var(--surface);
      overflow: hidden;
    }
    .story-card .img-wrap img { width: 100%; height: 100%; object-fit: cover; display: block; }
    .story-card .img-wrap .placeholder {
      width: 100%; height: 100%; min-height: 100px;
      display: flex; align-items: center; justify-content: center;
      color: var(--text-muted); font-size: 0.8rem;
    }
    .story-card .text-wrap {
      padding: 1rem 1.25rem;
      font-size: 0.9rem;
      line-height: 1.6;
      color: var(--text);
    }
    .story-card-actions {
      display: flex; gap: 0.5rem; margin-top: 0.75rem; padding-top: 0.75rem;
      border-top: 1px solid var(--border);
    }
    .story-card-actions button {
      font-size: 0.75rem; font-weight: 500; color: var(--text-muted);
      background: transparent; border: 1px solid var(--border);
      border-radius: 4px; padding: 0.3rem 0.6rem; cursor: pointer;
    }
    .story-card-actions button:hover { color: var(--accent); border-color: var(--accent); }
    .studio-description {
      font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap; word-break: break-word;
      padding: 1rem; background: var(--surface-hover); border: 1px solid var(--border);
      border-radius: var(--radius-sm); max-height: 200px; overflow-y: auto; color: var(--text);
    }
    .studio-meta-row { margin-bottom: 0.75rem; }
    .studio-meta-row-head {
      display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.35rem;
    }
    .studio-chip {
      font-size: 0.8rem; padding: 0.2rem 0.5rem;
      background: var(--surface-hover); border: 1px solid var(--border);
      border-radius: 4px; color: var(--text); display: inline-block; margin: 0.15rem 0.15rem 0 0;
    }
    .studio-chips { display: flex; flex-wrap: wrap; gap: 0.15rem; align-items: center; }
    .studio-keywords { display: flex; flex-direction: column; gap: 0.75rem; }
    .studio-keywords-block { }
    .studio-keywords-label { font-size: 0.7rem; font-weight: 600; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.03em; margin-bottom: 0.25rem; }
    .studio-copy-btn { font-size: 0.7rem; padding: 0.2rem 0.5rem; }
    .empty-state { text-align: center; padding: 2rem 1rem; color: var(--text-muted); }
    .empty-state p { margin: 0 0 0.5rem 0; font-size: 0.9rem; }
    .refresh { color: var(--accent); text-decoration: none; font-size: 0.9rem; font-weight: 500; }
    .refresh:hover { text-decoration: underline; }
    .tts-row {
      display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap;
      margin-bottom: 1rem; padding: 0.75rem 0; border-bottom: 1px solid var(--border);
    }
    .tts-row label { font-size: 0.8125rem; font-weight: 500; color: var(--text-muted); }
    .tts-row select {
      font-family: inherit; font-size: 0.9rem; padding: 0.4rem 0.75rem;
      background: var(--surface-hover); color: var(--text); border: 1px solid var(--border);
      border-radius: var(--radius-sm); min-width: 200px;
    }
    .tts-row select:focus { outline: 2px solid var(--accent); outline-offset: 2px; }
    .tts-credit { font-size: 0.9rem; color: var(--text); font-weight: 500; }
    .tts-credit .num { color: var(--success); }
    .youtube-progress-wrap { margin-top: 0.75rem; }
    .youtube-progress-bar { height: 8px; background: var(--bg); border-radius: 4px; overflow: hidden; }
    .youtube-progress-fill { height: 100%; background: var(--accent); border-radius: 4px; width: 0%; transition: width 0.2s ease; }
  </style>
</head>
<body>
  <div class="container">
    <header class="page-header">
      <div>
        <h1>Horror Podcast — YouTube Pipeline</h1>
        <p class="tagline">Story → Audio → Subtitles → Images → Video → Thumbnail. Run all or fix a step manually.</p>
      </div>
      <div class="header-actions">
        <a href="#" id="refreshStory" class="refresh">Refresh story</a>
      </div>
    </header>

    <div class="card">
      <h2 class="card-title">Pipeline</h2>
      <div class="tts-row">
        <label for="ttsSelect">TTS (Audio)</label>
        <select id="ttsSelect" aria-label="TTS provider">
          <option value="">Loading…</option>
        </select>
        <span id="ttsCredit" class="tts-credit"></span>
      </div>
      <p class="pipeline-intro">
        <strong>Run full pipeline</strong> to generate everything in order. If something fails, run the step that failed (or any step) manually below.
      </p>
      <div class="run-full-wrap">
        <button type="button" class="btn" id="runFullBtn">Run full pipeline</button>
      </div>
      <div class="steps-grid" id="stepsGrid"></div>
    </div>

    <div class="card">
      <h2 class="card-title">Video details (for YouTube Studio)</h2>
      <div id="unsplashHint" class="unsplash-hint" style="display: none;"></div>
      <div id="studioContent" style="display: none;">
        <div class="studio-section">
          <div class="studio-section-title">Title</div>
          <div id="storyTitleWrap"></div>
        </div>
        <div class="studio-section">
          <div class="studio-section-title">Story (paragraphs)</div>
          <div id="storyText" class="story-cards"></div>
          <div id="storyFallback" style="display: none;">
            <div id="storyFallbackText" class="studio-description"></div>
          </div>
        </div>
        <div class="studio-section">
          <div class="studio-meta-row-head">
            <span class="studio-section-title">Description</span>
            <button type="button" class="btn btn-outline btn-sm studio-copy-btn" id="copyDescBtn">Copy</button>
          </div>
          <div id="metaDescription" class="studio-description"></div>
        </div>
        <div class="studio-section">
          <div class="studio-section-title">Tags</div>
          <div id="metaTags" class="studio-chips"></div>
          <button type="button" class="btn btn-outline btn-sm" id="copyTagsBtn">Copy tags</button>
        </div>
        <div class="studio-section" id="metaKeywordsSection">
          <div class="studio-section-title">Keywords</div>
          <div id="metaKeywords" class="studio-keywords"></div>
        </div>
        <div class="studio-section" id="metaHashtagsSection">
          <div class="studio-section-title">Hashtags</div>
          <div id="metaHashtags" class="studio-chips"></div>
        </div>
        <div class="studio-section">
          <button type="button" class="btn btn-outline btn-sm" id="regenerateDescTagsBtn">Regenerate description &amp; tags</button>
          <span id="regenerateDescTagsStatus" class="tts-credit" style="margin-left: 0.5rem;"></span>
        </div>
      </div>
      <div id="storyPlaceholderWrap" class="empty-state">
        <p id="storyPlaceholder">No story yet. Run the <strong>Story</strong> step (or full pipeline) to generate.</p>
      </div>
    </div>

    <div class="card">
      <h2 class="card-title">Log</h2>
      <pre id="log"></pre>
    </div>

    <div class="card">
      <h2 class="card-title">Output</h2>
      <div class="output-grid">
        <div class="output-item">
          <label>Thumbnail</label>
          <img id="thumb" src="" alt="Thumbnail" style="display:none;" />
          <span id="thumbNone" class="output-placeholder">Not generated yet.</span>
        </div>
        <div class="output-item">
          <label>Video</label>
          <video id="video" controls style="display:none;" />
          <span id="videoNone" class="output-placeholder">Not generated yet.</span>
        </div>
      </div>
    </div>

    <div class="card">
      <h2 class="card-title">YouTube</h2>
      <p class="pipeline-intro">
        Connect your channel once (tokens saved to <code>auth/</code> — no .env edit needed). Then push the current video to YouTube.
      </p>
      <div class="tts-row" style="border-bottom: none; padding-bottom: 0;">
        <span id="youtubeStatusLabel" class="tts-credit" style="margin-right: 0.5rem;"></span>
        <a href="/api/youtube/auth" target="_blank" rel="noopener" class="btn btn-outline" id="youtubeConnectLink">Connect YouTube</a>
        <button type="button" class="btn" id="youtubeUploadBtn">Upload to YouTube</button>
        <span id="youtubeUploadStatus" class="tts-credit"></span>
      </div>
      <div id="youtubeProgressWrap" class="youtube-progress-wrap" style="display: none;">
        <div class="youtube-progress-bar"><div id="youtubeProgressFill" class="youtube-progress-fill"></div></div>
        <div id="youtubeProgressText" class="tts-credit" style="margin-top: 0.25rem;"></div>
      </div>
    </div>
  </div>

  <script>
    const STEPS = [
      { id: "story", label: "Story" },
      { id: "audio", label: "Audio" },
      { id: "subtitles", label: "Subtitles" },
      { id: "images", label: "Images" },
      { id: "video", label: "Video" },
      { id: "thumbnail", label: "Thumbnail" },
      { id: "regenerate-desc-tags", label: "Regenerate description & tags" },
    ];
    const logEl = document.getElementById("log");
    const runFullBtn = document.getElementById("runFullBtn");
    const stepsGrid = document.getElementById("stepsGrid");
    const ttsSelect = document.getElementById("ttsSelect");
    const ttsCredit = document.getElementById("ttsCredit");
    let runningStepId = null;
    let fullPipelineRunning = false;
    let ttsProviders = [];

    const TTS_STORAGE_KEY = "horror-pipeline-tts";

    function getSelectedTTS() {
      const v = ttsSelect?.value?.trim();
      return v || null;
    }

    async function loadTTSOptions() {
      try {
        const r = await fetch("/api/tts-options");
        const data = await r.json();
        ttsProviders = data.providers || [];
        ttsSelect.innerHTML = "";
        const saved = localStorage.getItem(TTS_STORAGE_KEY);
        let hasSelection = false;
        ttsProviders.forEach((p) => {
          const opt = document.createElement("option");
          opt.value = p.id;
          opt.textContent = `${p.label} — ${p.credit}`;
          opt.disabled = !p.available;
          if (p.available && (p.id === saved || (!saved && !hasSelection))) {
            opt.selected = true;
            hasSelection = true;
          }
          ttsSelect.appendChild(opt);
        });
        if (!hasSelection && ttsProviders.length) {
          const first = ttsProviders.find((p) => p.available);
          if (first) {
            ttsSelect.value = first.id;
            localStorage.setItem(TTS_STORAGE_KEY, first.id);
          }
        } else if (hasSelection && saved) {
          localStorage.setItem(TTS_STORAGE_KEY, ttsSelect.value);
        }
        updateTTSCreditLabel();
      } catch (e) {
        ttsSelect.innerHTML = '<option value="">Failed to load</option>';
      }
    }

    function updateTTSCreditLabel() {
      const id = ttsSelect?.value;
      const p = ttsProviders.find((x) => x.id === id);
      if (!p) {
        ttsCredit.innerHTML = "";
        return;
      }
      if (p.totalCredit != null && p.totalCredit > 0) {
        const label = p.id === "elevenlabs" ? "credits" : "keys";
        ttsCredit.innerHTML = `Total: <span class="num">${Number(p.totalCredit).toLocaleString()}</span> ${label}`;
      } else {
        ttsCredit.textContent = p.credit;
      }
    }

    ttsSelect?.addEventListener("change", () => {
      localStorage.setItem(TTS_STORAGE_KEY, ttsSelect.value || "");
      updateTTSCreditLabel();
    });

    async function fetchStatus() {
      try {
        const r = await fetch("/api/status");
        const data = await r.json();
        return data.steps || {};
      } catch {
        return {};
      }
    }

    function renderSteps(status) {
      stepsGrid.innerHTML = "";
      STEPS.forEach((s) => {
        const done = status[s.id];
        const running = runningStepId === s.id;
        const disabled = fullPipelineRunning || (runningStepId !== null && runningStepId !== s.id);
        const card = document.createElement("div");
        card.className = "step-card" + (done ? " done" : "") + (running ? " running" : "");
        card.innerHTML = `
          <span class="step-name">${s.label}</span>
          <span class="step-meta"><span class="step-status-dot"></span>${done ? "Ready" : "Not run"}</span>
          <button type="button" class="btn btn-outline btn-sm" data-step="${s.id}" ${disabled ? "disabled" : ""}>Run</button>
        `;
        card.querySelector("button").addEventListener("click", () => runStep(s.id));
        stepsGrid.appendChild(card);
      });
    }

    function setStepRunning(stepId, running) {
      runningStepId = running ? stepId : null;
      runFullBtn.disabled = !!running;
      document.querySelectorAll(".step-card").forEach((card) => {
        const btn = card.querySelector("button");
        const id = btn?.dataset.step;
        card.classList.toggle("running", running && id === stepId);
        if (btn) btn.disabled = running && id !== stepId;
      });
    }

    function streamRun(url, onDone) {
      const tts = getSelectedTTS();
      const sep = url.includes("?") ? "&" : "?";
      const fullUrl = tts ? `${url}${sep}tts=${encodeURIComponent(tts)}` : url;
      logEl.textContent = "Running…\n";
      const es = new EventSource(fullUrl);
      es.addEventListener("log", (e) => {
        const d = JSON.parse(e.data);
        if (d.line) {
          logEl.textContent += d.line + "\n";
          if (/Story generated|\[1\/6\]/.test(d.line)) loadStory();
        }
        logEl.scrollTop = logEl.scrollHeight;
      });
      es.addEventListener("done", (e) => {
        const d = JSON.parse(e.data);
        logEl.textContent += "\nFinished (exit " + d.code + ").\n";
        es.close();
        onDone();
        fetchStatus().then(renderSteps);
        loadStory();
        showOutputs();
      });
      es.addEventListener("error", (e) => {
        logEl.textContent += "\nError.\n";
        es.close();
        onDone();
        fetchStatus().then(renderSteps);
      });
    }

    function runStep(stepId) {
      setStepRunning(stepId, true);
      streamRun("/api/run/step/" + stepId, () => setStepRunning(stepId, false));
    }

    function runFull() {
      fullPipelineRunning = true;
      runFullBtn.disabled = true;
      fetchStatus().then(renderSteps);
      streamRun("/api/run", () => {
        fullPipelineRunning = false;
        runFullBtn.disabled = false;
        fetchStatus().then(renderSteps);
      });
    }

    runFullBtn.addEventListener("click", runFull);

    loadTTSOptions();

    let unsplashKeyMissingShown = false;
    async function fetchUnsplashUrl(query) {
      try {
        const r = await fetch("/api/unsplash?query=" + encodeURIComponent(query));
        const d = await r.json();
        if (r.status === 503 && !unsplashKeyMissingShown) {
          unsplashKeyMissingShown = true;
          const hint = document.getElementById("unsplashHint");
          hint.innerHTML = "<strong>Images unavailable.</strong> " + (d.hint || d.error || "");
          hint.style.display = "block";
        }
        return d.url || null;
      } catch (e) {
        return null;
      }
    }

    const storyTitleWrap = document.getElementById("storyTitleWrap");
    const storyText = document.getElementById("storyText");
    const storyFallback = document.getElementById("storyFallback");
    const storyFallbackText = document.getElementById("storyFallbackText");
    const storyPlaceholderWrap = document.getElementById("storyPlaceholderWrap");
    const storyPlaceholder = document.getElementById("storyPlaceholder");
    const thumb = document.getElementById("thumb");
    const thumbNone = document.getElementById("thumbNone");
    const video = document.getElementById("video");
    const videoNone = document.getElementById("videoNone");

    async function loadStory() {
      try {
        const r = await fetch("/api/story");
        const data = await r.json();
        if (!data.story && (!data.paragraphs || !data.paragraphs.length)) {
          document.getElementById("studioContent").style.display = "none";
          storyPlaceholderWrap.style.display = "block";
          storyPlaceholder.textContent = "No story yet. Run the Story step (or full pipeline) to generate.";
          return;
        }
        storyPlaceholderWrap.style.display = "none";
        document.getElementById("studioContent").style.display = "block";

        const titleQuery = (data.titleImagePrompt && data.titleImagePrompt.trim()) || (data.scenes && data.scenes[0]) || "Hindi horror story cinematic";
        storyTitleWrap.innerHTML = '<div class="title-section"><div class="title-section-img-wrap"><span class="placeholder">Loading…</span></div><div class="title-section-text">' + (data.title || "").replace(/</g, "&lt;") + "</div></div>";
        const titleImgWrap = storyTitleWrap.querySelector(".title-section-img-wrap");
        const titleImageUrl = await fetchUnsplashUrl(titleQuery);
        if (titleImageUrl) {
          const img = document.createElement("img");
          img.src = titleImageUrl;
          img.alt = titleQuery;
          titleImgWrap.innerHTML = "";
          titleImgWrap.appendChild(img);
        } else {
          titleImgWrap.innerHTML = '<span class="placeholder">No image</span>';
        }

        const rawParagraphs = data.paragraphs && data.paragraphs.length
          ? data.paragraphs
          : (data.story || "").split(/\n\n+/).map((t) => t.trim()).filter(Boolean).map((text, i) => {
              const scenes = data.scenes && data.scenes.length ? data.scenes : ["horror cinematic"];
              return { text, imagePrompt: scenes[i % scenes.length] };
            });
        const paragraphs = rawParagraphs.filter((p) => p.text);

        if (paragraphs.length === 0) {
          storyFallbackText.textContent = data.story || "";
          storyFallback.style.display = "block";
          storyText.style.display = "none";
          renderStudioMeta(data);
          document.getElementById("copyDescBtn").onclick = () => copyToClipboard(data.description || "", "copyDescBtn", "Copy");
          return;
        }

        storyFallback.style.display = "none";
        storyText.style.display = "block";
        storyText.innerHTML = "";

        renderStudioMeta(data);
        document.getElementById("copyDescBtn").onclick = () => copyToClipboard(data.description || "", "copyDescBtn", "Copy");

        for (let i = 0; i < paragraphs.length; i++) {
          const p = paragraphs[i];
          const card = document.createElement("div");
          card.className = "story-card";
          const imgWrap = document.createElement("div");
          imgWrap.className = "img-wrap";
          imgWrap.innerHTML = '<span class="placeholder">Loading…</span>';
          const textWrap = document.createElement("div");
          textWrap.className = "text-wrap";
          textWrap.textContent = p.text;
          const actions = document.createElement("div");
          actions.className = "story-card-actions";
          const copyParaBtn = document.createElement("button");
          copyParaBtn.type = "button";
          copyParaBtn.textContent = "Copy paragraph";
          copyParaBtn.addEventListener("click", () => {
            navigator.clipboard.writeText(p.text).then(() => { copyParaBtn.textContent = "Copied!"; setTimeout(() => { copyParaBtn.textContent = "Copy paragraph"; }, 1500); });
          });
          actions.appendChild(copyParaBtn);
          card.appendChild(imgWrap);
          card.appendChild(textWrap);
          card.appendChild(actions);
          storyText.appendChild(card);

          const query = (p.imagePrompt || "horror").trim();
          const url = await fetchUnsplashUrl(query);
          if (url) {
            const img = document.createElement("img");
            img.src = url;
            img.alt = query;
            imgWrap.innerHTML = "";
            imgWrap.appendChild(img);
          } else {
            imgWrap.innerHTML = '<span class="placeholder">No image</span>';
          }
        }

        const tags = toTagsArray(data.tags);
        document.getElementById("copyTagsBtn").onclick = () => copyToClipboard(tags.join(", "), "copyTagsBtn", "Copy tags");
      } catch (e) {
        document.getElementById("studioContent").style.display = "none";
        storyPlaceholderWrap.style.display = "block";
        storyPlaceholder.textContent = "Could not load story.";
      }
    }

    function copyToClipboard(text, btnId, resetLabel) {
      navigator.clipboard.writeText(text).then(() => {
        const btn = document.getElementById(btnId);
        if (btn) {
          btn.textContent = "Copied!";
          setTimeout(() => { btn.textContent = resetLabel; }, 2000);
        }
      });
    }

    function toTagsArray(v) {
      if (Array.isArray(v)) return v.map((t) => String(t).trim()).filter(Boolean);
      if (typeof v === "string") return v.split(",").map((s) => s.trim()).filter(Boolean);
      return [];
    }

    function renderStudioMeta(data) {
      document.getElementById("metaDescription").textContent = data.description || "";
      const tagsContainer = document.getElementById("metaTags");
      tagsContainer.innerHTML = "";
      toTagsArray(data.tags).forEach((t) => {
        const span = document.createElement("span");
        span.className = "studio-chip";
        span.textContent = t;
        tagsContainer.appendChild(span);
      });
      const keywordsEl = document.getElementById("metaKeywords");
      keywordsEl.innerHTML = "";
      const kw = data.keywords || {};
      const keywordLabels = [
        { key: "tripleKeywords", label: "Triple keywords" },
        { key: "highVolumeTags", label: "High volume" },
        { key: "rankedTags", label: "Ranked" },
        { key: "highRankedKeywords", label: "High ranked" },
      ];
      keywordLabels.forEach(({ key, label }) => {
        const list = Array.isArray(kw[key]) ? kw[key] : [];
        if (list.length === 0) return;
        const block = document.createElement("div");
        block.className = "studio-keywords-block";
        const title = document.createElement("div");
        title.className = "studio-keywords-label";
        title.textContent = label;
        block.appendChild(title);
        const chips = document.createElement("div");
        chips.className = "studio-chips";
        list.forEach((item) => {
          const span = document.createElement("span");
          span.className = "studio-chip";
          span.textContent = item;
          chips.appendChild(span);
        });
        block.appendChild(chips);
        keywordsEl.appendChild(block);
      });
      const hashtagsContainer = document.getElementById("metaHashtags");
      hashtagsContainer.innerHTML = "";
      toTagsArray(data.hashtags).forEach((h) => {
        const span = document.createElement("span");
        span.className = "studio-chip";
        span.textContent = h;
        hashtagsContainer.appendChild(span);
      });
    }

    function showOutputs() {
      thumb.src = "/api/thumb?t=" + Date.now();
      thumb.onload = () => { thumb.style.display = "block"; thumbNone.style.display = "none"; };
      thumb.onerror = () => { thumbNone.style.display = "inline"; thumb.style.display = "none"; };
      video.src = "/api/video?t=" + Date.now();
      video.onloadeddata = () => { video.style.display = "block"; videoNone.style.display = "none"; };
      video.onerror = () => { videoNone.style.display = "inline"; video.style.display = "none"; };
    }

    document.getElementById("refreshStory").addEventListener("click", (e) => {
      e.preventDefault();
      loadStory();
    });

    document.getElementById("regenerateDescTagsBtn")?.addEventListener("click", async () => {
      const btn = document.getElementById("regenerateDescTagsBtn");
      const statusEl = document.getElementById("regenerateDescTagsStatus");
      btn.disabled = true;
      statusEl.textContent = "Regenerating…";
      try {
        const r = await fetch("/api/story/regenerate-description-tags", { method: "POST" });
        const data = await r.json().catch(() => ({}));
        if (r.ok && data.ok) {
          statusEl.textContent = "Done.";
          loadStory();
        } else {
          statusEl.textContent = data.error || "Failed.";
        }
      } catch (e) {
        statusEl.textContent = e.message || "Error";
      }
      btn.disabled = false;
      setTimeout(() => { statusEl.textContent = ""; }, 3000);
    });

    async function loadYoutubeStatus() {
      const label = document.getElementById("youtubeStatusLabel");
      const link = document.getElementById("youtubeConnectLink");
      try {
        const r = await fetch("/api/youtube/status");
        const data = await r.json();
        if (data.connected) {
          label.textContent = "✓ YouTube connected";
          label.style.color = "var(--success)";
          link.textContent = "Reconnect";
        } else {
          label.textContent = "";
          link.textContent = "Connect YouTube";
        }
      } catch (_) {
        label.textContent = "";
      }
    }

    document.getElementById("youtubeUploadBtn")?.addEventListener("click", async () => {
      const btn = document.getElementById("youtubeUploadBtn");
      const status = document.getElementById("youtubeUploadStatus");
      const wrap = document.getElementById("youtubeProgressWrap");
      const fill = document.getElementById("youtubeProgressFill");
      const progressText = document.getElementById("youtubeProgressText");
      btn.disabled = true;
      status.textContent = "";
      wrap.style.display = "block";
      fill.style.width = "0%";
      progressText.textContent = "Uploading… 0%";
      try {
        const r = await fetch("/api/youtube/upload", {
          method: "POST",
          headers: { Accept: "text/event-stream" },
        });
        if (!r.ok || !r.body) {
          const data = await r.json().catch(() => ({}));
          throw new Error(data.error || "Upload failed");
        }
        const reader = r.body.getReader();
        const dec = new TextDecoder();
        let buf = "";
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;
          buf += dec.decode(value, { stream: true });
          const lines = buf.split("\n\n");
          buf = lines.pop() || "";
          for (const line of lines) {
            if (line.startsWith("data: ")) {
              try {
                const data = JSON.parse(line.slice(6));
                if (data.progress != null) {
                  fill.style.width = data.progress + "%";
                  progressText.textContent = data.done ? "Done." : `Uploading… ${data.progress}%`;
                }
                if (data.done) {
                  status.textContent = data.message || data.error || "Uploaded.";
                  if (data.message) loadYoutubeStatus();
                  if (data.error) throw new Error(data.error);
                }
              } catch (_) {}
            }
          }
        }
        if (status.textContent === "") status.textContent = "Uploaded.";
      } catch (e) {
        status.textContent = e.message || "Error";
        progressText.textContent = "Failed.";
      }
      btn.disabled = false;
      setTimeout(() => { wrap.style.display = "none"; }, 2500);
    });

    loadYoutubeStatus();
    fetchStatus().then(renderSteps);
    loadStory();
    showOutputs();
  </script>
</body>
</html>
